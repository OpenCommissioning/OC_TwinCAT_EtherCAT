<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_Beckhoff_EL6001" Id="{bb75b897-d30a-02f1-3a96-629f2f38e7fc}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Beckhoff_EL6001
VAR_INPUT
	bSend				: BOOL;
	nLength				: UINT;
	pDataIn				: POINTER TO BYTE; //Data to send
	pDataOut			: POINTER TO BYTE; //Received data when nDataAvailable > 0.
END_VAR
VAR_OUTPUT
	bBusy				: BOOL;
	nDataAvailable		: INT; //Received bytes. Only available for one cycle.
END_VAR
VAR
	nControl			AT %I* : UINT;
	nDataOut			AT %I* : ARRAY[0..21] OF USINT;
	nStatus				AT %Q* : UINT;
	nDataIn				AT %Q* : ARRAY[0..21] OF USINT;
END_VAR
VAR
	nControlByte		: BYTE;
	nOutLength			: BYTE;	
	bTransmitRequest	: BOOL;
	bReceiveAccecpted	: BOOL;
	bInitRequest		: BOOL;
	bSendContinuous		: BOOL;
	
	bTransmitAccepted	: BOOL;
	bReceiveRequest		: BOOL;
	bInitAccepted		: BOOL;
	bBufferFull			: BOOL;
	bParityError		: BOOL;
	bFramingError		: BOOL;
	bOverrunError		: BOOL;
	nInLength			: BYTE;
	
	nPendingLength		: UINT;
	nOffsetNext			: UINT;
	
	nState				: BYTE;
	trigSend			: R_TRIG;
END_VAR

VAR CONSTANT
	READY		: BYTE := 0;
	INIT		: BYTE := 1;
	TRANSMIT	: BYTE := 3;
	RECEIVE		: BYTE := 4;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* Receive control word *)
	bTransmitRequest 	:= nControl.0 <> nControlByte.0;
	bReceiveAccecpted 	:= nControl.1 <> nControlByte.1;
	bInitRequest		:= nControl = 4;
	bSendContinuous		:= nControl.3 AND NOT nControlByte.0;	
	nControlByte 		:= F_GetLByte(nControl);
	nOutLength 			:= F_GetHByte(nControl);

(* Initialize *)
	IF bInitRequest THEN
		nState := INIT;			
	END_IF
	
CASE nState OF
	
	READY:
		nDataAvailable := 0;

		// -> TRANSMIT
		IF bTransmitRequest AND nOutLength > 0 AND nOutLength < 23 THEN
			nState := TRANSMIT;
			RETURN;
		END_IF
		
		trigSend(CLK := bSend);
		
		// -> RECEIVE
		IF trigSend.Q AND nLength > 0 AND pDataIn <> 0 THEN
			bReceiveRequest := NOT bReceiveRequest;
			nPendingLength := nLength;
			nInLength := UINT_TO_BYTE(MIN(22, nPendingLength));
			memcpy(ADR(nDataIn), pDataIn, nInLength);		
			nState := RECEIVE;
		END_IF
		
	INIT:
		bTransmitAccepted 	:= FALSE;
		bReceiveRequest		:= FALSE;
		bInitAccepted		:= TRUE;
		bBufferFull			:= FALSE;
		bParityError		:= FALSE;
		bFramingError		:= FALSE;
		bOverrunError		:= FALSE;
		nInLength			:= 0;
		nDataAvailable		:= 0;
		
		// -> INIT_READY
		IF nControl = 0 THEN
			bInitAccepted := FALSE;		
			nState := READY;
		END_IF
		
	TRANSMIT:
		IF pDataOut <> 0 THEN
			memcpy(pDataOut, ADR(nDataOut), nOutLength);
		END_IF
		bTransmitAccepted := NOT bTransmitAccepted;
		nDataAvailable := nOutLength;
		nState := READY;
		
	RECEIVE:
		IF bReceiveAccecpted THEN
			nOffsetNext := nInLength;
			nPendingLength := nPendingLength - nOffsetNext;
			IF nPendingLength = 0 THEN
				nState := READY;
			END_IF
			IF nPendingLength > 0 THEN
				bReceiveRequest := NOT bReceiveRequest;
				nInLength := UINT_TO_BYTE(MIN(22, nPendingLength));
				memcpy(ADR(nDataIn), pDataIn + nOffsetNext, nInLength);
				nState := RECEIVE;
			END_IF				
		END_IF
	
END_CASE

bBusy := nState <> READY;
	
(* Send status word *)
	nStatus.0			:= bTransmitAccepted;
	nStatus.1			:= bReceiveRequest;
	nStatus.2			:= bInitAccepted;
	nStatus.3			:= bBufferFull;
	nStatus.4			:= bParityError;
	nStatus.5			:= bFramingError;
	nStatus.6			:= bOverrunError;
	memcpy(ADR(nStatus) + 1, ADR(nInLength), 1);	]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>